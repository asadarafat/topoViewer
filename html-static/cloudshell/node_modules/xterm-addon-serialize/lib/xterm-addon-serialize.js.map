{"version":3,"sources":["webpack://SerializeAddon/webpack/universalModuleDefinition","webpack://SerializeAddon/./src/SerializeAddon.ts","webpack://SerializeAddon/webpack/bootstrap","webpack://SerializeAddon/webpack/startup"],"names":["root","factory","exports","module","define","amd","self","equalBg","cell1","cell2","getBgColorMode","getBgColor","_buffer1","_terminal","_rowIndex","_allRows","Array","_allRowSeparators","_currentRow","_nullCellCount","_cursorStyle","getNullCell","_cursorStyleRow","_cursorStyleCol","_backgroundCell","_firstRow","_lastCursorRow","_lastCursorCol","_lastContentCursorRow","_lastContentCursorCol","_this","_thisRowLastChar","_thisRowLastSecondChar","_nextRowFirstChar","_beforeSerialize","rows","start","end","this","_rowEnd","row","isLastRow","rowSeparator","getLine","getCell","currentLine","nextLine","isWrapped","thisRowLastChar","length","thisRowLastSecondChar","nextRowFirstChar","isNextRowFirstCharDoubleWidth","getWidth","isValid","getChars","repeat","_diffStyle","cell","oldCell","sgrSeq","fgChanged","getFgColorMode","getFgColor","bgChanged","flagsChanged","isInverse","isBold","isUnderline","isBlink","isInvisible","isItalic","isDim","equalFlags","isAttributeDefault","push","color","isFgRGB","isFgPalette","isBgRGB","isBgPalette","_nextCell","col","isEmptyCell","join","line","undefined","_serializeString","rowEnd","content","i","offset","realCursorRow","baseY","cursorY","realCursorCol","cursorX","moveRight","_buffer","serialize","startRow","endRow","c","console","warn","_afterSerialize","activate","terminal","_getString","buffer","scrollback","value","high","maxRows","handler","StringSerializeHandler","correctRows","Math","max","min","Error","active","type","normal","alternate","dispose","SerializeAddon","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","call"],"mappings":"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","file":"xterm-addon-serialize.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SerializeAddon\"] = factory();\n\telse\n\t\troot[\"SerializeAddon\"] = factory();\n})(self, function() {\nreturn ","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n *\n * (EXPERIMENTAL) This Addon is still under development\n */\n\nimport { Terminal, ITerminalAddon, IBuffer, IBufferCell } from 'xterm';\n\nfunction constrain(value: number, low: number, high: number): number {\n  return Math.max(low, Math.min(value, high));\n}\n\n// TODO: Refine this template class later\nabstract class BaseSerializeHandler {\n  constructor(private _buffer: IBuffer) { }\n\n  public serialize(startRow: number, endRow: number): string {\n    // we need two of them to flip between old and new cell\n    const cell1 = this._buffer.getNullCell();\n    const cell2 = this._buffer.getNullCell();\n    let oldCell = cell1;\n\n    this._beforeSerialize(endRow - startRow, startRow, endRow);\n\n    for (let row = startRow; row < endRow; row++) {\n      const line = this._buffer.getLine(row);\n      if (line) {\n        for (let col = 0; col < line.length; col++) {\n          const c = line.getCell(col, oldCell === cell1 ? cell2 : cell1);\n          if (!c) {\n            console.warn(`Can't get cell at row=${row}, col=${col}`);\n            continue;\n          }\n          this._nextCell(c, oldCell, row, col);\n          oldCell = c;\n        }\n      }\n      this._rowEnd(row, row === endRow - 1);\n    }\n\n    this._afterSerialize();\n\n    return this._serializeString();\n  }\n\n  protected _nextCell(cell: IBufferCell, oldCell: IBufferCell, row: number, col: number): void { }\n  protected _rowEnd(row: number, isLastRow: boolean): void { }\n  protected _beforeSerialize(rows: number, startRow: number, endRow: number): void { }\n  protected _afterSerialize(): void { }\n  protected _serializeString(): string { return ''; }\n}\n\nfunction equalFg(cell1: IBufferCell, cell2: IBufferCell): boolean {\n  return cell1.getFgColorMode() === cell2.getFgColorMode()\n    && cell1.getFgColor() === cell2.getFgColor();\n}\n\nfunction equalBg(cell1: IBufferCell, cell2: IBufferCell): boolean {\n  return cell1.getBgColorMode() === cell2.getBgColorMode()\n    && cell1.getBgColor() === cell2.getBgColor();\n}\n\nfunction equalFlags(cell1: IBufferCell, cell2: IBufferCell): boolean {\n  return cell1.isInverse() === cell2.isInverse()\n    && cell1.isBold() === cell2.isBold()\n    && cell1.isUnderline() === cell2.isUnderline()\n    && cell1.isBlink() === cell2.isBlink()\n    && cell1.isInvisible() === cell2.isInvisible()\n    && cell1.isItalic() === cell2.isItalic()\n    && cell1.isDim() === cell2.isDim();\n}\n\n\n\nclass StringSerializeHandler extends BaseSerializeHandler {\n  private _rowIndex: number = 0;\n  private _allRows: string[] = new Array<string>();\n  private _allRowSeparators: string[] = new Array<string>();\n  private _currentRow: string = '';\n  private _nullCellCount: number = 0;\n\n  // we can see a full colored cell and a null cell that only have background the same style\n  // but the information isn't preserved by null cell itself\n  // so wee need to record it when required.\n  private _cursorStyle: IBufferCell = this._buffer1.getNullCell();\n\n  // where exact the cursor styles comes from\n  // because we can't copy the cell directly\n  // so we remember where the content comes from instead\n  private _cursorStyleRow: number = 0;\n  private _cursorStyleCol: number = 0;\n\n  // this is a null cell for reference for checking whether background is empty or not\n  private _backgroundCell: IBufferCell = this._buffer1.getNullCell();\n\n  private _firstRow: number = 0;\n  private _lastCursorRow: number = 0;\n  private _lastCursorCol: number = 0;\n  private _lastContentCursorRow: number = 0;\n  private _lastContentCursorCol: number = 0;\n\n  constructor(private _buffer1: IBuffer, private _terminal: Terminal) {\n    super(_buffer1);\n  }\n\n  protected _beforeSerialize(rows: number, start: number, end: number): void {\n    this._allRows = new Array<string>(rows);\n    this._lastContentCursorRow = start;\n    this._lastCursorRow = start;\n    this._firstRow = start;\n  }\n\n  private _thisRowLastChar: IBufferCell = this._buffer1.getNullCell();\n  private _thisRowLastSecondChar: IBufferCell = this._buffer1.getNullCell();\n  private _nextRowFirstChar: IBufferCell = this._buffer1.getNullCell();\n  protected _rowEnd(row: number, isLastRow: boolean): void {\n    // if there is colorful empty cell at line end, whe must pad it back, or the the color block will missing\n    if (this._nullCellCount > 0 && !equalBg(this._cursorStyle, this._backgroundCell)) {\n      // use clear right to set background.\n      this._currentRow += `\\x1b[${this._nullCellCount}X`;\n    }\n\n    let rowSeparator = '';\n\n    // handle row separator\n    if (!isLastRow) {\n      // Enable BCE\n      if (row - this._firstRow >= this._terminal.rows) {\n        this._buffer1.getLine(this._cursorStyleRow)?.getCell(this._cursorStyleCol, this._backgroundCell);\n      }\n\n      // Fetch current line\n      const currentLine = this._buffer1.getLine(row)!;\n      // Fetch next line\n      const nextLine = this._buffer1.getLine(row + 1)!;\n\n      if (!nextLine.isWrapped) {\n        // just insert the line break\n        rowSeparator = '\\r\\n';\n        // we sended the enter\n        this._lastCursorRow = row + 1;\n        this._lastCursorCol = 0;\n      } else {\n        rowSeparator = '';\n        const thisRowLastChar = currentLine.getCell(currentLine.length - 1, this._thisRowLastChar)!;\n        const thisRowLastSecondChar = currentLine.getCell(currentLine.length - 2, this._thisRowLastSecondChar)!;\n        const nextRowFirstChar = nextLine.getCell(0, this._nextRowFirstChar)!;\n        const isNextRowFirstCharDoubleWidth = nextRowFirstChar.getWidth() > 1;\n\n        // validate whether this line wrap is ever possible\n        // which mean whether cursor can placed at a overflow position (x === row) naturally\n        let isValid = false;\n\n        if (\n          // you must output character to cause overflow, control sequence can't do this\n          nextRowFirstChar.getChars() &&\n          isNextRowFirstCharDoubleWidth ? this._nullCellCount <= 1 : this._nullCellCount <= 0\n        ) {\n          if (\n            // the last character can't be null,\n            // you can't use control sequence to move cursor to (x === row)\n            (thisRowLastChar.getChars() || thisRowLastChar.getWidth() === 0) &&\n            // change background of the first wrapped cell also affects BCE\n            // so we mark it as invalid to simply the process to determine line separator\n            equalBg(thisRowLastChar, nextRowFirstChar)\n          ) {\n            isValid = true;\n          }\n\n          if (\n            // the second to last character can't be null if the next line starts with CJK,\n            // you can't use control sequence to move cursor to (x === row)\n            isNextRowFirstCharDoubleWidth &&\n            (thisRowLastSecondChar.getChars() || thisRowLastSecondChar.getWidth() === 0) &&\n            // change background of the first wrapped cell also affects BCE\n            // so we mark it as invalid to simply the process to determine line separator\n            equalBg(thisRowLastChar, nextRowFirstChar) &&\n            equalBg(thisRowLastSecondChar, nextRowFirstChar)\n          ) {\n            isValid = true;\n          }\n        }\n\n        if (!isValid) {\n          // force the wrap with magic\n          // insert enough character to force the wrap\n          rowSeparator = '-'.repeat(this._nullCellCount + 1);\n          // move back and erase next line head\n          rowSeparator += '\\x1b[1D\\x1b[1X';\n\n          if (this._nullCellCount > 0) {\n            // do these because we filled the last several null slot, which we shouldn't\n            rowSeparator += '\\x1b[A';\n            rowSeparator += `\\x1b[${currentLine.length - this._nullCellCount}C`;\n            rowSeparator += `\\x1b[${this._nullCellCount}X`;\n            rowSeparator += `\\x1b[${currentLine.length - this._nullCellCount}D`;\n            rowSeparator += '\\x1b[B';\n          }\n\n          // This is content and need the be serialized even it is invisible.\n          // without this, wrap will be missing from outputs.\n          this._lastContentCursorRow = row + 1;\n          this._lastContentCursorCol = 0;\n\n          // force commit the cursor position\n          this._lastCursorRow = row + 1;\n          this._lastCursorCol = 0;\n        }\n      }\n    }\n\n    this._allRows[this._rowIndex] = this._currentRow;\n    this._allRowSeparators[this._rowIndex++] = rowSeparator;\n    this._currentRow = '';\n    this._nullCellCount = 0;\n  }\n\n  private _diffStyle(cell: IBufferCell, oldCell: IBufferCell): number[] {\n    const sgrSeq: number[] = [];\n    const fgChanged = !equalFg(cell, oldCell);\n    const bgChanged = !equalBg(cell, oldCell);\n    const flagsChanged = !equalFlags(cell, oldCell);\n\n    if (fgChanged || bgChanged || flagsChanged) {\n      if (cell.isAttributeDefault()) {\n        if (!oldCell.isAttributeDefault()) {\n          sgrSeq.push(0);\n        }\n      } else {\n        if (fgChanged) {\n          const color = cell.getFgColor();\n          if (cell.isFgRGB()) { sgrSeq.push(38, 2, (color >>> 16) & 0xFF, (color >>> 8) & 0xFF, color & 0xFF); }\n          else if (cell.isFgPalette()) {\n            if (color >= 16) { sgrSeq.push(38, 5, color); }\n            else { sgrSeq.push(color & 8 ? 90 + (color & 7) : 30 + (color & 7)); }\n          }\n          else { sgrSeq.push(39); }\n        }\n        if (bgChanged) {\n          const color = cell.getBgColor();\n          if (cell.isBgRGB()) { sgrSeq.push(48, 2, (color >>> 16) & 0xFF, (color >>> 8) & 0xFF, color & 0xFF); }\n          else if (cell.isBgPalette()) {\n            if (color >= 16) { sgrSeq.push(48, 5, color); }\n            else { sgrSeq.push(color & 8 ? 100 + (color & 7) : 40 + (color & 7)); }\n          }\n          else { sgrSeq.push(49); }\n        }\n        if (flagsChanged) {\n          if (cell.isInverse() !== oldCell.isInverse()) { sgrSeq.push(cell.isInverse() ? 7 : 27); }\n          if (cell.isBold() !== oldCell.isBold()) { sgrSeq.push(cell.isBold() ? 1 : 22); }\n          if (cell.isUnderline() !== oldCell.isUnderline()) { sgrSeq.push(cell.isUnderline() ? 4 : 24); }\n          if (cell.isBlink() !== oldCell.isBlink()) { sgrSeq.push(cell.isBlink() ? 5 : 25); }\n          if (cell.isInvisible() !== oldCell.isInvisible()) { sgrSeq.push(cell.isInvisible() ? 8 : 28); }\n          if (cell.isItalic() !== oldCell.isItalic()) { sgrSeq.push(cell.isItalic() ? 3 : 23); }\n          if (cell.isDim() !== oldCell.isDim()) { sgrSeq.push(cell.isDim() ? 2 : 22); }\n        }\n      }\n    }\n\n    return sgrSeq;\n  }\n\n  protected _nextCell(cell: IBufferCell, oldCell: IBufferCell, row: number, col: number): void {\n    // a width 0 cell don't need to be count because it is just a placeholder after a CJK character;\n    const isPlaceHolderCell = cell.getWidth() === 0;\n\n    if (isPlaceHolderCell) {\n      return;\n    }\n\n    // this cell don't have content\n    const isEmptyCell = cell.getChars() === '';\n\n    const sgrSeq = this._diffStyle(cell, this._cursorStyle);\n\n    // the empty cell style is only assumed to be changed when background changed, because foreground is always 0.\n    const styleChanged = isEmptyCell ? !equalBg(this._cursorStyle, cell) : sgrSeq.length > 0;\n\n    /**\n     *  handles style change\n     */\n    if (styleChanged) {\n      // before update the style, we need to fill empty cell back\n      if (this._nullCellCount > 0) {\n        // use clear right to set background.\n        if (!equalBg(this._cursorStyle, this._backgroundCell)) {\n          this._currentRow += `\\x1b[${this._nullCellCount}X`;\n        }\n        // use move right to move cursor.\n        this._currentRow += `\\x1b[${this._nullCellCount}C`;\n        this._nullCellCount = 0;\n      }\n\n      this._lastContentCursorRow = this._lastCursorRow = row;\n      this._lastContentCursorCol = this._lastCursorCol = col;\n\n      this._currentRow += `\\x1b[${sgrSeq.join(';')}m`;\n\n      // update the last cursor style\n      const line = this._buffer1.getLine(row);\n      if (line !== undefined) {\n        line.getCell(col, this._cursorStyle);\n        this._cursorStyleRow = row;\n        this._cursorStyleCol = col;\n      }\n    }\n\n    /**\n     *  handles actual content\n     */\n    if (isEmptyCell) {\n      this._nullCellCount += cell.getWidth();\n    } else {\n      if (this._nullCellCount > 0) {\n        // we can just assume we have same style with previous one here\n        // because style change is handled by previous stage\n        // use move right when background is empty, use clear right when there is background.\n        if (equalBg(this._cursorStyle, this._backgroundCell)) {\n          this._currentRow += `\\x1b[${this._nullCellCount}C`;\n        } else {\n          this._currentRow += `\\x1b[${this._nullCellCount}X`;\n          this._currentRow += `\\x1b[${this._nullCellCount}C`;\n        }\n        this._nullCellCount = 0;\n      }\n\n      this._currentRow += cell.getChars();\n\n      // update cursor\n      this._lastContentCursorRow = this._lastCursorRow = row;\n      this._lastContentCursorCol = this._lastCursorCol = col + cell.getWidth();\n    }\n  }\n\n  protected _serializeString(): string {\n    let rowEnd = this._allRows.length;\n\n    // the fixup is only required for data without scrollback\n    // because it will always be placed at last line otherwise\n    if (this._buffer1.length - this._firstRow <= this._terminal.rows) {\n      rowEnd = this._lastContentCursorRow + 1 - this._firstRow;\n      this._lastCursorCol = this._lastContentCursorCol;\n      this._lastCursorRow = this._lastContentCursorRow;\n    }\n\n    let content = '';\n\n    for (let i = 0; i < rowEnd; i++) {\n      content += this._allRows[i];\n      if (i + 1 < rowEnd) {\n        content += this._allRowSeparators[i];\n      }\n    }\n\n    // restore the cursor\n    const realCursorRow = this._buffer1.baseY + this._buffer1.cursorY;\n    const realCursorCol = this._buffer1.cursorX;\n\n    const cursorMoved = (realCursorRow !== this._lastCursorRow || realCursorCol !== this._lastCursorCol);\n\n    const moveRight = (offset: number): void => {\n      if (offset > 0) {\n        content += `\\u001b[${offset}C`;\n      } else if (offset < 0) {\n        content += `\\u001b[${-offset}D`;\n      }\n    };\n    const moveDown = (offset: number): void => {\n      if (offset > 0) {\n        content += `\\u001b[${offset}B`;\n      } else if (offset < 0) {\n        content += `\\u001b[${-offset}A`;\n      }\n    };\n\n    if (cursorMoved) {\n      moveDown(realCursorRow - this._lastCursorRow);\n      moveRight(realCursorCol - this._lastCursorCol);\n    }\n\n\n    return content;\n  }\n}\n\nexport class SerializeAddon implements ITerminalAddon {\n  private _terminal: Terminal | undefined;\n\n  constructor() { }\n\n  public activate(terminal: Terminal): void {\n    this._terminal = terminal;\n  }\n\n  private _getString(buffer: IBuffer, scrollback?: number): string {\n    const maxRows = buffer.length;\n    const handler = new StringSerializeHandler(buffer, this._terminal!);\n\n    const correctRows = (scrollback === undefined) ? maxRows : constrain(scrollback + this!._terminal!.rows, 0, maxRows);\n    const result = handler.serialize(maxRows - correctRows, maxRows);\n\n    return result;\n  }\n\n  public serialize(scrollback?: number): string {\n    // TODO: Add combinedData support\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n\n    if (this._terminal.buffer.active.type === 'normal') {\n      return this._getString(this._terminal.buffer.active, scrollback);\n    }\n\n    const normalScreenContent = this._getString(this._terminal.buffer.normal, scrollback);\n    // alt screen don't have scrollback\n    const alternativeScreenContent = this._getString(this._terminal.buffer.alternate, undefined);\n\n    return normalScreenContent\n      + '\\u001b[?1049h\\u001b[H'\n      + alternativeScreenContent;\n  }\n\n  public dispose(): void { }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(44);\n"],"sourceRoot":""}